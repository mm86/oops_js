in a program without any functions, every variable is a global scope and all variables are stored in the global scope.
global scope can also be shared across mutlipel files.

after defining a variable in a lexical scope, you may make reference to that variable from anyhwere else in that lexical scope.
a new lexical scope is created everytime you type out a function definition.the function definition spans from the letter f all 

the way down to the end curly brace. the two curly braces around the function's body enclosed the area of the code where
different access rules will apply.let's color in all the area between these braces to represent the region that will have new rules, and that we could thus consider a different lexical scope. once you've made a new lexical scope by defining a function,
it has a few more limits than the lexical scope around it. although you can still access variables from the broader lexical scope containing that interlexical scope and you can acess variables(var foil) that get defined inside that inner scope, the variables that you define in the inner scope cannot be reffered to from outside that scope(log(foil) outside the curly brace.
Outside these curly braces referring to a variable that was local to the inner scope will result in an error.
the variables that will be available within the body of the new saga function? awhat variables can you access within these two curly braces? hero, newsaga and foil. the newsaga function is the tightest scoped function avaliable and so it has access
to all the outer functions.

var hero = aHero();
var newSaga = function(){
  var foil = aFoil();



 log(foil);
};
log(hero);

Note: JS allows you to assign to variables youve never even declared before.in this example, i took the var statement off of this assignment operation.so foil has not been declared anywhere in our whole program. when you are doing this kind of assignment, variables that you are assigning to for the first time will be added automatically to the global scope and not to whatever scope you did the assignment in. this is a bad practice, leaving the var keyword off is more often done as an accident not on purpose.

also note that unlike other languages, not all curly braces in JS are relevant for scoping.blocks on if statements or while statements and other looping constructs do nto create new scopes. only the curly braces that you find on a function statement creates a scope. scoping limitations are actually very useful.they allow us to think about less of our porgram all at once.

var hero = aHero();
if(checkSomething()){
  var foil = aFoil();
}
log(foil);

so it seems like variables are being accessed correctly now in accordance with the rules of lexical scoping. but our program needs to call the 
newsaga function in order for it to do anything useful.lets call the function twice so we can see two newsaga functions playing out.
we also need to make sure the inner function saga gets called.

var hero = aHero();
var newSaga = function(){<-- red color
   var foil = aFoil();
   var saga = function(){<--blue color
   var deed = aDeed();
   log(hero+deed+foil);
   };
   saga();
   saga();
};

newSaga();
newSaga();

we are done listing lexical scopes in this program,we've seen how to differentiate one lexical scope from another,
and we've learned the rules that govern them.it's time to talk of a different idea relating to a different usage of the word scope.

when a prgram runs, it builds up storage systems for holding the variables and their values. These in-memory scope structures
are called execution contexts. execution contexts or in-memory scopes differ from lexical scopes, in that they are built as
the code runs and not as its typed.The rules govern which  variables a program has access to at different points during 
the execution.lets explore how variables will be available at runtime within different contexts.

As the program runs, it will be building up internal data stores for keeping track of all the variables that are available
to different function objects. This will be a picture of our in-memory system. since each new run of a function is supposed 
to operate in complete isolation from all previous runs, a new execution context should be created every time you 
run a function. Thus, for each lexical scope there may be many in-memory scopes created during execution or none. It 
all depends on how many times you run a function in your code. To examine execution contextx, we need to run this program
before the first line of code even runs, the interpreter will start out by setting up an execution environment for you.

The first step will be to create an in-memory global scope context to hold all the global variables.
so lets visualize the execution context data store off to the right here. we'll use a similar color as the lexical
scope region that it relates to.
